import React, { useState } from 'react';
import {useThree} from 'react-three-fiber';
import ClickMarker from './ClickMarker';
import Gplane from './Gplane';
import * as THREE from 'three';

export default function DragControls(props) {
    const {
        scene,
        camera: {
            current: camera = null
        } = {}
    } = useThree() || {};

    const [isClickMarkerVisible, setIsClickMarkerVisible] = useState(false);
    const [clickMarkerPos, setClickMarkerPos] = useState([0, 0, 0]);
    const [mousePoint, setMousePoint] = useState(null);
    const [jointBody, setJointBody] = useState(null);
    const [constrainedBody, setConstrainedBody] = useState(null);

    const projector = new THREE.Projector();

    window.addEventListener("mousemove", onMouseMove, false );
    window.addEventListener("mousedown", onMouseDown, false );
    window.addEventListener("mouseup", onMouseUp, false );

    function onMouseMove(e){
        // Move and project on the plane
        if (mouseConstraint) {
            var pos = projectOntoPlane(e.clientX,e.clientY,gplane,camera);
            if(pos){
                setClickMarker(pos.x,pos.y,pos.z,scene);
                moveJointToPoint(pos.x,pos.y,pos.z);
            }
        }
    }
    
    function onMouseDown(e){
        // Find mesh from a ray
        var entity = findNearestIntersectingObject(e.clientX, e.clientY);
        var pos = entity.point;
        if(pos && entity.object.geometry instanceof THREE.BoxGeometry){
            constraintDown = true;
            // Set marker on contact point
            setClickMarker(pos.x, pos.y, pos.z);
    
            // Set the movement plane
            setMousePoint(pos);
    
            console.log(entity.object);
            // var idx = meshes.indexOf(entity.object);
            // if(idx !== -1){
            //     addMouseConstraint(pos.x,pos.y,pos.z,bodies[idx]);
            // }
        }
    }

    function findNearestIntersectingObject(clientX, clientY) {
        // Get the picking ray from the point
        const raycaster = getRayCasterFromScreenCoord(clientX, clientY);
    
        // Find the closest intersecting object
        // Now, cast the ray all render objects in the scene to see if they collide. Take the closest one.
        const hits = raycaster.intersectObjects(objects);
        let closest = false;
        if (hits.length > 0) {
            closest = hits[0];
        }
    
        return closest;
    }
    
    // Function that returns a raycaster to use to find intersecting objects
    // in a scene given screen pos and a camera, and a projector
    function getRayCasterFromScreenCoord (screenX, screenY) {
        const mouse3D = new THREE.Vector3();
        // Get 3D point form the client x y
        mouse3D.x = (screenX / window.innerWidth) * 2 - 1;
        mouse3D.y = -(screenY / window.innerHeight) * 2 + 1;
        mouse3D.z = 0.5;
        return projector.pickingRay(mouse3D, camera);
    }
    

    function setClickMarker(x, y, z) {
        setIsClickMarkerVisible(true);
        setClickMarkerPos([x, y, z]);
    }

    function removeClickMarker(){
        setIsClickMarkerVisible(false);
    }
      
    return (
        <>
            <ClickMarker visible={isClickMarkerVisible} position={clickMarkerPos} />
            <Gplane point={mousePoint}/>
        </>
    );
}